# 👨‍🏫 week 28 - A

## ▣ 2장 : 타입스크립트의 타입 시스템

### ▣ ㄴ 아이템9 : 타입 단언보다는 타입 선언을 사용하기

### ▣ ㄴ 아이템10 : 객체 래퍼 타입 피하기

### ▣ ㄴ 아이템11 : 잉여 속성 체크의 한계 인지하기

### ▣ ㄴ 아이템12 : 함수 표현식에 타입 적용하기

### ▣ ㄴ 아이템13 : 타입과 인터페이스 차이점 알기

### ▣ ㄴ 아이템14 : 타입 연산과 제너릭 사용으로 반복줄이기

### 1️⃣ Q. 타입 단언보다는 타입 선언을 사용해야 하는 이유와 타입 단언이 꼭 필요한 경우는?

타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사하기 때문에, 안전성을 보장하는 측면에서 유리합니다.  
반면, 타입 단언은 값에 대한 타입을 강제로 지정하는 것으로, 타입 체커에게 오류를 무시하라는 의미입니다.

즉, 타입 선언문은 잉여 속성 체크(타입이 명시된 변수에 객체 리터럴을 할당할 때, 해당 타입의 속성이 있는지 확인)가 동작하지만,  
단언문에는 이러한 체크가 적용되지 않습니다.

따라서 가능한 경우에는 타입 선언을 사용하는 것이 안전하며 권장됩니다.

하지만 타입 단언이 꼭 필요한 경우도 있습니다.
예를 들어, TypeScript는 DOM에 접근할 때 정확한 타입을 추론하지 못할 수 있습니다.
이런 상황에서는 타입 단언을 사용하여 원하는 타입을 직접 지정하는 것이 더 적합할 수 있습니다.

또한, 값이 `null`이 아님을 확신할 수 있는 경우 `!` 접미사를 사용하여 타입 체커에게 해당 값을 `null`로 처리하지 않도록 할 수 있습니다.
<br/>

### 2️⃣ Q. 기본형에 속성을 할당했을 때 그 속성이 사라지는 이유는 무엇인가요?

```
  > x = "hello"
  > x.language = "English"
  "English"
  > x.language
  undefined
```

기본형(primitive types)인 문자열 x에 속성을 추가하려고 하면, JavaScript는 일시적으로 기본형을 래퍼 객체(wrapper object)로 변환합니다.  
예를 들어, 문자열인 x는 내부적으로 String 객체로 변환됩니다.  
속성인 language가 이 객체에 추가되지만, 이 객체는 곧바로 버려지고, 다시 기본형으로 돌아갑니다.
이 과정에서 래퍼 객체에 추가된 속성은 메모리에서 해제되기 때문에, 이후에 x.language를 호출하면 해당 속성은 존재하지 않아 undefined가 반환됩니다.

따라서 기본형에 속성을 추가하려고 하면, 래퍼 객체의 일시적 생성과 삭제 때문에 속성이 사라지는 현상이 발생합니다.

---

기본형(primitive type)인 값에 속성을 직접 할당할 수는 없기 때문에 속성을 유지하려면 객체(object)나 래퍼 객체를 사용

1. **객체를 사용하는 방법**: 값을 객체로 감싸서 속성을 할당

    ```javascript
    let x = { value: "hello" };
    x.language = "English";

    console.log(x.language); // "English"
    ```

2. **래퍼 객체를 명시적으로 사용하는 방법**: 기본형을 래퍼 객체로 변환하여 속성을 할당할 수 있습니다. 예를 들어, `String` 객체로 변환해서 사용합니다.

    ```javascript
    let x = new String("hello");
    x.language = "English";

    console.log(x.language); // "English"
    ```

일반적으로는 객체를 사용.

<br/>

### 3️⃣ Q. 타입과 인터페이스의 차이는 무엇인가요?

-   **확장성**:

    -   **인터페이스**는 다른 **인터페이스**를 확장할 수 있으며, **타입**도 확장할 수 있습니다.
    -   **타입** 역시 다른 **타입**과 **인터페이스**를 확장할 수 있습니다.

-   **유니온 타입**:

    -   **인터페이스**는 유니온 타입과 같은 복잡한 타입을 확장할 수 없습니다.
    -   반면, **타입**은 유니온(`|`)이나 인터섹션(`&`)을 사용해 더 복잡한 구조를 표현할 수 있습니다.

-   **보강(Declaration Merging)**:

    -   **인터페이스**는 동일한 이름으로 여러 번 선언하면 자동으로 합쳐지는 **보강**이 가능합니다.  
        즉, 같은 이름의 인터페이스가 여러 개 있어도 TypeScript가 이를 하나로 합쳐줍니다.
    -   **타입**은 보강이 불가능하며, 동일한 이름으로 선언하려 하면 오류가 발생합니다.

-   **사용 상황**:
    -   **인터페이스**는 주로 객체의 구조를 정의하는 데 사용하며, 보강이 가능하므로 라이브러리 확장 등에 유리합니다.
    -   **타입**은 함수, 유니온, 튜플 등 보다 다양한 복잡한 타입을 정의하는 데 적합합니다.

**결론**: 인터페이스는 보강과 확장성이 뛰어나 객체 지향적 개발에 유리하며, 타입은 유니온 및 복잡한 타입 표현에 더 유연하게 사용될 수 있습니다.
