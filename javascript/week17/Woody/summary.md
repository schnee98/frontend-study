# 👩‍🏫 week 17 - Q

## ▣ 19.8장: 오버라이딩과 프로퍼티 섀도잉
## ▣ 19.9장: 프로토타입의 교체

<details>
  <summary><b><i>오버라이딩(overriding)과 오버로딩(overloading)</i></b></summary>
  <div markdown="1">
  자바스크립트에서의 오버라이딩(overriding)과 오버로딩(overloading)은 객체 지향 프로그래밍에서 중요한 개념들 중 하나입니다.  
  두 용어는 종종 혼동될 수 있지만, 기능적으로 매우 다릅니다.

  ### 오버라이딩 (Overriding)

  오버라이딩은 자식 클래스가 부모 클래스로부터 상속받은 메서드를 재정의(다시 쓰기)하는 것을 의미합니다.  
  즉, 원래의 메서드를 자식 클래스에 맞게 수정하여 사용하는 것입니다. 
  이를 통해 같은 이름의 메서드가 상속 관계에서 다른 동작을 할 수 있게 됩니다.

  자바스크립트 예제:
  ```javascript
  class Animal {
      speak() {
          return "This animal makes a sound.";
      }
  }

  class Dog extends Animal {
      speak() {
          return "Woof! Woof!";
      }
  }

  let pet = new Dog();
  console.log(pet.speak()); // "Woof! Woof!"
  ```
  위의 예에서 `Dog` 클래스는 `Animal` 클래스의 `speak` 메서드를 오버라이딩하여 개가 짖는 소리를 내도록 했습니다.

  ### 오버로딩 (Overloading)

  오버로딩은 같은 이름의 함수나 메서드를 매개변수의 수나 타입에 따라 다르게 동작하도록 정의하는 것을 의미합니다.  
  하지만 자바스크립트는 전통적인 오버로딩을 지원하지 않습니다. 대신, 함수 내에서 매개변수를 확인하여 다양한 동작을 할 수 있도록 설계할 수 있습니다.

  자바스크립트 예제:
  ```javascript
  function add(x, y) {
      if (y !== undefined) {
          return x + y;
      } else {
          return x + x; // y가 주어지지 않은 경우 x와 x를 더함
      }
  }

  console.log(add(5, 3));  // 8
  console.log(add(5));     // 10 (5 + 5)
  ```
  이 예제에서는 `add` 함수가 매개변수의 수에 따라 다른 동작을 하도록 만들었습니다.

  이렇게 오버라이딩은 상속된 메서드의 재정의를 통해 구현하고, 오버로딩은 매개변수의 유연한 처리를 통해 유사한 효과를 내는 것으로 자바스크립트에서 활용됩니다.
  </div>
</details>
---

<details>
  <summary><b><i>프로퍼티(property)와 메서드(method)</i></b></summary>
  <div markdown="1">
  자바스크립트에서 프로퍼티(property)와 메서드(method)는 객체에 속한 멤버이지만, 역할과 용도가 다릅니다.

  ### 프로퍼티 (Property)
  프로퍼티는 객체에 속한 변수로서 값을 저장하는 역할을 합니다.   
  이 값은 기본 데이터 타입(숫자, 문자열, 불리언 등)일 수도 있고, 다른 객체나 함수(이 경우 함수 역시 객체임) 등 모든 종류의 데이터가 될 수 있습니다.

  **예시:**
  ```javascript
  let person = {
    name: "Alice",
    age: 25
  };
  ```
  위 예시에서 `name`과 `age`는 `person` 객체의 프로퍼티입니다.  
  이 프로퍼티들은 각각 문자열과 숫자 값을 저장하고 있습니다.

  ### 메서드 (Method)
  메서드는 객체에 속한 함수로서, 특정 작업을 수행하기 위해 객체의 내부 데이터에 접근할 수 있는 함수입니다.  
  메서드는 객체의 프로퍼티 값에 접근하고 조작할 수 있으며, 객체의 행동을 정의합니다.

  **예시:**
  ```javascript
  let person = {
    name: "Alice",
    age: 25,
    greet: function() {
      console.log(`Hello, my name is ${this.name}`);
    }
  };

  person.greet();  // 출력: "Hello, my name is Alice"
  ```
  위 예시에서 `greet`는 `person` 객체의 메서드입니다.  
  이 메서드는 객체 내의 `name` 프로퍼티에 접근하여 특정 행동(인사말 출력)을 수행합니다.

  ### 차이점 요약
  - **프로퍼티**: 객체의 상태를 저장하거나 표현하는 값. 숫자, 문자열, 불리언, 객체, 함수 등이 포함될 수 있음.
  - **메서드**: 객체의 행동이나 기능을 정의하는 함수. 객체의 프로퍼티에 접근하고, 객체와 관련된 동작을 수행함.

  간단히 말해, 프로퍼티는 데이터를 저장하고, 메서드는 행동을 정의합니다.  
  프로퍼티가 객체의 상태를 나타낸다면, 메서드는 그 상태를 활용하여 무언가를 실행하는 역할을 합니다.

  </div>
</details>
---

<br/>

생성자 함수로 Person이라는 객체(인스턴스)를 생성한 다음 인스턴스에 sayHello라는 메서드를 추가합니다.  
프로토타입 프로퍼티와 같은 이름의 sayHello라는 프로퍼티를 인스턴스에 추가하면,
해당 인스턴스는 프로토타입 체인을 통해 상속받은 같은 이름의 sayHello메서드(프로토타입 메서드)를 오버라이딩합니다.  

이는 인스턴스 자체에 새로운 프로퍼티(이 경우에는 메서드)가 추가되면, 이 프로퍼티(이 경우에는 메서드)가 먼저 참조되기 때문입니다.

이때 상속 관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉이라고 합니다.

자바스크립트에서 메서드나 프로퍼티를 참조할 때, 엔진은 다음과 같은 순서로 찾습니다:
1. 인스턴스 자체에 해당 프로퍼티가 있는지 검사합니다.
2. 없다면, 프로토타입 체인을 따라 상위 객체의 프로퍼티를 검사합니다.
3. 만약 인스턴스에 직접 추가한 메서드가 있다면, 그 메서드는 프로토타입 체인을 따라 같은 이름의 메서드보다 우선하여 사용됩니다. 
이는 오버라이딩의 기본 개념과 일치합니다.

### 프로토타입의 삭제
프로퍼티를 삭제하기 위해서는 delete 연산자를 사용합니다.  
delete 연산자는 객체의 프로퍼티를 제거하며, 성공적으로 제거된 경우 true를 반환합니다.
프로퍼티를 삭제할 때는 하위 객체를 통해 프로토 타입의 프로퍼티를 변경, 삭제하는 것은 불가능합니다.
즉 하위객체를 통해 프로토타입에 get엑세스는 허용, set엑세는 허용하지 않습니다.

그래서 변경, 삭제하려면 프로토타입에 직접 접근해야합니다.
```js
delete Person.prototype.sayHello;
```

### 프로토타입의 교체
프로토타입 교체는 자바스크립트의 객체가 다른 객체로부터 상속받는 행동을 변경할 때 사용됩니다.  
`__proto__` 접근자 프로퍼티를 통해 가능하며, ES2015(ES6) 이후로는 `Object.setPrototypeOf()` 메서드를 사용하는 것이 권장됩니다.  
`__proto__` 프로퍼티는 일반적으로 사용하지 않는 것이 좋습니다.  
왜냐하면 이는 비표준이고 성능 저하를 일으킬 수 있기 때문입니다.   

#### 프로토타입 교체 예시 
다음은 간단한 생성자 함수 `Animal`과 `Dog`를 정의하고,  
프로토타입 교체를 통해 `Dog` 인스턴스가 `Animal`의 프로토타입을 상속받도록 변경하는 예입니다.
(이해를 돕기 위한 `__proto__`를 사용한 예)

```javascript
function Animal() {
  this.type = "animal";
}

Animal.prototype.speak = function() {
  return "This animal makes a sound.";
};

function Dog(name) {
  this.name = name;
}

// Dog의 인스턴스 생성
let dog = new Dog("Woody");

// Dog 인스턴스의 프로토타입을 Animal의 프로토타입으로 교체
dog.__proto__ = Animal.prototype;

console.log(dog.speak());  // "This animal makes a sound."
```

#### 프로토타입 교체의 영향
프로토타입을 교체하면, 해당 객체는 새로운 프로토타입에 정의된 프로퍼티와 메서드에 접근할 수 있습니다.  
그러나 이는 다음과 같은 부작용을 초래할 수 있습니다.

1. **생성자 연결 파괴**: 프로토타입을 교체하면, 객체의 생성자(`constructor`) 프로퍼티가 새로운 프로토타입의 생성자를 가리키게 됩니다.  
이는 객체가 어떤 생성자 함수로부터 생성되었는지 추적하는 데 혼란을 줄 수 있습니다.  
예를 들어, `dog.constructor`는 `Animal`을 가리키게 될 수 있습니다.

```javascript
console.log(dog.constructor.name);  // "Woody"가 아니라 "Animal"
```

2. **성능 저하**: 프로토타입 체인의 변경은 자바스크립트 엔진 최적화에 영향을 줄 수 있습니다.  
따라서, 프로토타입 교체는 가능한 한 적게 사용하고, 객체의 초기화 단계에서만 수행하는 것이 좋습니다.

### 안전한 프로토타입 교체 방법
`Object.setPrototypeOf()` 함수를 사용하여 프로토타입을 교체하는 것이 더 안전하고 표준적인 방법입니다.

```javascript
Object.setPrototypeOf(dog, Animal.prototype);
console.log(dog.speak());  // "This animal makes a sound."
```

프로토타입 교체는 특정 상황에서 유용할 수 있지만,  
객체의 프로토타입을 변경하는 것은 성능과 유지 보수 측면에서 비용이 발생할 수 있으므로 신중하게 사용해야 합니다.  

객체의 동작을 동적으로 변경할 필요가 있는 경우에만 교체를 고려하고,  
가능하다면 객체 생성 시점에서 적절한 프로토타입을 설정하는 것이 더 바람직합니다.

### 교체하는 두 가지 방법
자바스크립트에서 프로토타입 교체는 두 가지 방법으로 수행할 수 있습니다.  
첫 번째는 생성자 함수의 프로토타입을 변경하는 것이고, 두 번째는 개별 인스턴스의 프로토타입을 변경하는 것입니다.  
각 방법은 객체의 동작과 상속 구조에 다른 영향을 미칩니다.

#### 1. 생성자 함수에 의한 프로토타입 교체
이 방법은 특정 생성자 함수에서 생성된 모든 인스턴스의 프로토타입을 교체합니다.  
이는 생성자 함수의 `prototype` 속성을 변경함으로써 수행됩니다.  
이렇게 하면 해당 생성자로 생성된 모든 새 인스턴스는 변경된 프로토타입을 상속받게 됩니다.  

**예시:**
```javascript
function Animal() {
    this.type = "Animal";
}

function Woody() {
    this.canFly = false;
}

Animal.prototype.move = function() {
    return "This animal moves";
};

// 모든 Woody 인스턴스가 Animal 프로토타입을 상속받도록 변경
Woody.prototype = Object.create(Animal.prototype);

const Andy = new Woody();
console.log(Andy.type); // undefined, type은 Woody 인스턴스에 없음
console.log(Andy.move()); // "This animal moves"
```

- **Before**: `Woody.prototype`은 별도의 객체를 참조하고 있습니다.
- **After**: `Woody.prototype`은 `Animal.prototype`을 참조하게 변경되어, `Andy` 같은 `Woody` 인스턴스가 `Animal`의 메서드에 접근할 수 있게 됩니다.

#### 2. 인스턴스에 의한 프로토타입 교체
이 방법은 특정 인스턴스의 프로토타입만을 교체합니다.  
이는 `Object.setPrototypeOf()`를 사용하여 특정 인스턴스의 프로토타입을 직접 변경함으로써 수행됩니다.  
이 변경은 해당 인스턴스에만 영향을 미칩니다.

**예시:**
```javascript
function Cat() {
    this.lives = 9;
}

Cat.prototype.mew = function() {
    return "mew!";
};

const 냥냥 = new Cat();

// 냥냥 인스턴스의 프로토타입을 Animal 프로토타입으로 교체
Object.setPrototypeOf(냥냥, Animal.prototype);

console.log(냥냥.mew()); // TypeError: 냥냥.mew is not a function
console.log(냥냥.move()); // "This animal moves"
```

- **Before**: `냥냥` 인스턴스는 `Cat.prototype`을 참조하고 있습니다.
- **After**: `냥냥`의 프로토타입이 `Animal.prototype`으로 교체되어, `냥냥`는 이제 `Cat`의 메서드에는 접근할 수 없고, `Animal`의 메서드에 접근할 수 있습니다.


<details>
  <summary><b><i>참고</i></b></summary>
  <div markdown="1">
  Javascript에서는 객체를 상속하기 위하여 프로토타입이라는 방식을 사용한다. 라고 MDN에 나와있습니다.  
  프로토타입에 대한 얕은 이해를 하게 되면 클래스의 상속을 떠올리게 되는데,  
  `프로토타입 !== 상속` 프로토타입과 상속은 엄연히 다른 것 입니다.  

  왜냐하면 자바스크립트에 클래스는 없기 때문입니다.  
  그렇기 때문에 자바스크립트에서 '복사'를 통한 상속은 없습니다.  
  즉 프로토타입은 `프로토타입 === 연결`로 클래스, 객체의 내용 복사 없이도 상속을 구현할 수 있게 해주는 방법입니다.  

  자바스크립트에서 프로토타입을 사용하는 것은 분명 상속의 한 형태입니다.     
  다만, 이것이 전통적인 클래스 기반 언어에서의 상속과는 몇 가지 중요한 차이점이 있습니다.   
  이러한 차이 때문에 일부에서는 프로토타입을 이용한 상속을 '상속'이라고 부르는 것에 대해 다르게 표현하곤 합니다.  

  ### 프로토타입 기반 상속의 특징

  1. **연결을 통한 상속**: 프로토타입 상속은 객체 간의 프로퍼티와 메서드를 복사하는 것이 아니라, '연결'을 통해 상속이 이루어집니다. 즉, 상속받는 객체(자식)는 상속을 주는 객체(부모 프로토타입)의 프로퍼티와 메서드에 대한 참조를 가지게 됩니다. 이러한 연결은 프로토타입 체인을 통해 이루어집니다.

  2. **동적 수정 가능**: 프로토타입 체인은 실행 중에도 수정이 가능합니다. 예를 들어, 프로토타입 객체에 새로운 메서드나 프로퍼티를 추가하면, 이 변경 사항이 즉시 모든 상속받는 인스턴스에 반영됩니다. 이는 클래스 기반 언어에서 볼 수 없는 동적 특성입니다.

  3. **프로토타입 체인 검색**: 자식 객체에서 요청한 프로퍼티나 메서드를 찾을 때, 자신의 객체 내부에서 먼저 찾고, 없을 경우에 프로토타입 체인을 따라 부모 프로토타입에서 찾습니다. 이 과정은 프로토타입 체인의 끝에 도달할 때까지 계속됩니다.

  ### 클래스 기반 상속과의 차이

  - **클래스 정의**: 클래스 기반 언어에서는 클래스를 정의하고, 이 클래스의 인스턴스를 생성합니다. 상속은 클래스 간에 정의되며, 상속받은 인스턴스는 부모 클래스의 복사본을 가지고 생성됩니다.
  - **상속 메커니즘**: 클래스 기반 상속은 부모 클래스의 프로퍼티와 메서드를 자식 클래스의 인스턴스에 복사하는 방식으로 이루어집니다. 반면, 자바스크립트에서는 연결을 통해 프로토타입의 프로퍼티와 메서드에 접근합니다.

  ### 결론

  따라서, 프로토타입을 사용한 자바스크립트의 상속 방식은 전통적인 클래스 기반의 상속과는 다르지만, 여전히 '상속'이라고 부를 수 있는 것입니다.   이는 객체 간에 기능과 속성을 전달하고 확장할 수 있는 유연하고 동적인 방법을 제공합니다.  
  프로토타입을 사용한 상속은 자바스크립트의 중요한 특성 중 하나이며, 이 언어의 객체 지향적 접근 방식을 이해하는 데 핵심적입니다.
  </div>
</details>

- `.__proto__` : 객체와 객체를 연결하는 링크

- 프로토타입 체이닝: `__proto__`를 따라 단방향(상위레벨방향) 탐색하기 





