### 1. 함수 내부에서 외부 상태를 직접 참조하지 않더라도 매개변수를 통해 객체를 전달받으면 비순수 함수가 된다. 그 이유를 설명하고 객체를 매개변수로 전달받더라도 순수함수가 될 수 있도록 하려면 어떻게 전달해야 할지 설명하세요.
- 객체 타입 인수는 참조 값이 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 참조 값을 통해 객체를 변경할 수 있다. 객체를 매개변수로 전달하게 되면 원본 객체가 변경되는 부수 효과가 발생하기 때문에 비순순함수가 된다.
- 순수함수로 만들기 위해서는 매개변수로 전달하고자 하는 객체를 복사해 전달하거나, 객체를 전달할 때 함수 내에서 객체를 변경하지 않고 새로운 객체를 반환하도록 한다.

### 2. 아래 코드에서 함수 선언문은 에러가 나지 않고, 함수 표현식은 에러가 나는 이유를 설명하세요.
```
console.dir(add); // f add(x, y)
console.dir(sub); // undefined

console.dir(add(2, 5)); // 7
console.dir(sub(2, 5)); // TypeError: sub is not ad function

function add(x, y) {
    return x + y;
}

var sub = function (x, y) {
    return x - y;
}
```

- 함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성되고 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성해 생성된 함수 객체를 식별자에 할당한다. 코드가 실행되는 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태이다. 따라서 함수 선언문 이전에 함수를 참조할 수 있으며 호출할 수도 있다.
- 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이다. 런타임에 변수 할당문의 값이 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되기 때문에 에러가 난다.


### 3. 아래 코드와 같이 매개변수보다 인수가 더 많은 경우 초과된 인수는 어떻게 되는지 설명하세요.
```
function add(x, y) {
    console.log(arguments)
    return x + y
}

add(2, 5, 10)
```

- 초과된 인수는 버려지지 않고 암묵적으로 arguments 객체의 프로퍼티로 보관된다.
```
function add(x, y) {
    console.log(arguments)
    return x + y
}

add(2, 5, 10)
VM667:2 Arguments(3) [2, 5, 10, callee: ƒ, Symbol(Symbol.iterator): ƒ]
```