# 👩‍🏫 week 4 - A

## ▣ 12장: 함수

```js
// 함수 선언문
function add(x, y) {
  return x + y;
}
```

```js
// 함수 표현식
let sub = function (x, y) {
  return x + y;
};
// ES6 화살표 함수
let sub = (x, y) => x + y;
```

### 1️⃣ Q. 함수 선언문 대신 함수 표현식을 사용할 것을 권장하는 이유는 무엇일까요?

함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.
그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.
이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다.

모든 선언문이 그렇듯 함수 선언문도 코드가 한 줄씩 순차적으로 실행되는 시점인 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다.
다시 말해서, 런타임 이전에 함수 객체가 먼저 생성된다.
그리고 자바스크립트 엔진이 함수 이름과 동일한 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다.
즉 코드가 한 줄씩 순차적으로 실행되기 시작하는 런타임에는 이미
함수객체가 생성되어 있고 함수이름과 동일한 식별자에 할당까지 완료된 상태이다.

따라서 함수 선언문 이전에 함수를 참조, 호출할 수 있는 것이다.(함수 호이스팅)

함수 선언문으로 정의한 함수를 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능하다.  
함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.  
함수 표현식 이전에 함수를 참조하면 undefined로 평가된다.  
따라서 이때 함수를 호출하면 undefined를 호출하는 것과 마찬가지이므로 타입 에러가 발생한다.

함수 호이스팅은 함수를 호출하기 이전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시한다.
이 같은 문제 때문에 함수 선언문대신 함수 표현식을 사용할 것을 권장한다.

### 2️⃣ Q. ⭕❌

- 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크한다. (❌)
  개수가 일치하는지 체크하지 않는다.

- 매개변수보다 인수가 더 많은 경우 초과된 인수는 버려진다. (❌)  
  모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다.

- return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다. (⭕)
