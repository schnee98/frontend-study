# React의 useDeferredValue 분석

React의 useDeferredValue는 UI 반응성 향상을 위한 중요한 훅으로, 특히 무거운 렌더링 작업이 있을 때 사용자 경험을 개선하는 데 도움이 됩니다.

## 1. useDeferredValue의 존재 이유와 필요성

useDeferredValue는 React 18에서 소개된 훅으로, `값`의 업데이트 우선순위를 낮춰 UI 반응성을 유지하기 위해 설계되었습니다. 

**존재 이유 및 필요성:**
- 사용자 입력과 같은 높은 우선순위 업데이트와 무거운 렌더링 작업 사이의 균형을 맞추기 위함
- 입력 값이 변경될 때 화면이 버벅거리지 않도록 하면서도 최신 데이터를 반영할 수 있게 함
- 무거운 렌더링 작업이 사용자 상호작용을 차단하지 않도록 함

## 2. useDeferredValue 없을 때 생기는 문제점

useDeferredValue가 없으면 다음과 같은 문제가 발생할 수 있습니다:

- **UI 지연 및 버벅거림**: 사용자 입력에 따라 무거운 렌더링이 바로 실행되면 타이핑 같은 작업이 지연되고 부자연스러워짐
- **입력 지연**: 사용자가 입력할 때마다 화면이 응답하지 않아 사용자 경험이 저하됨
- **메인 스레드 차단**: JavaScript는 싱글 스레드이므로 무거운 렌더링이 UI 업데이트를 차단할 수 있음
- **불필요한 리렌더링**: 중간 상태들이 모두 즉시 렌더링되어 자원이 낭비됨

## 3. useDeferredValue 필요한 상황 예시

### 예시 설명:

1. **큰 데이터셋 필터링**: 10,000개 항목을 필터링하는 무거운 작업
2. **문제 상황**: 사용자 타이핑에 즉시 반응하면 UI가 버벅거림
3. **해결책**: 
   - `deferredQuery = useDeferredValue(query)`로 지연된 값 생성
   - 무거운 필터링은 지연된 쿼리를 사용하여 수행
   - 입력은 즉시 반응하고, 필터링은 우선순위가 낮은 작업으로 처리됨

4. **UX 개선**:
   - `isStale` 변수로 사용자에게 데이터가 업데이트 중임을 알림
   - 입력 필드는 항상 즉시 반응
   - 결과 목록은 사용자 입력을 차단하지 않고 나중에 업데이트됨

### useDeferredValue의 역할:

이 예시에서 useDeferredValue는 사용자 입력(`query`)의 "지연된 사본"을 만들어 무거운 필터링 작업에 사용합니다. 이렇게 하면:

1. 사용자 입력은 즉시 반영됨 (UI 반응성 유지)
2. 무거운 필터링은 React가 여유가 있을 때만 수행됨
3. 필터링 중에도 UI가 반응적으로 유지됨

## 4. 오래된 컨텐츠와 useDeferredValue의 목적

useDeferredValue는 단순히 "오래된" 콘텐츠를 보여주는 것이 아닙니다.  
이 훅의 진정한 목적은:

1. **우선순위 조정**: 무거운 렌더링 작업보다 사용자 입력을 우선시함
2. **점진적 업데이트**: 이전 값을 유지하면서 백그라운드에서 새 값으로 업데이트
3. **사용자 경험 최적화**: 사용자에게 앱이 반응하고 있다는 느낌을 주면서 최종 결과로 점진적으로 전환

### `isLoading` 처리와의 차이점은:
- `isLoading`은 일반적으로 외부 데이터 로딩을 처리하는 반면, useDeferredValue는 렌더링 비용이 높은 UI 요소를 처리
- useDeferredValue는 React의 동시성 모드를 활용하여 렌더링 우선순위를 자동으로 관리
- 이전 값을 유지하면서 새 값으로 자연스럽게 전환되도록 함

## 5. useDeferredValue와 useMemo의 관계

useDeferredValue는 `useMemo와 함께 사용될 때 가장 효과적`입니다:

- useDeferredValue는 **값**의 우선순위를 낮춤
- useMemo는 **계산 결과를 캐싱**하여 불필요한 재계산 방지
- 함께 사용하면, 지연된 값이 변경될 때만 무거운 계산을 수행

useTransition 역시 useMemo와 함께 사용될 수 있지만, 약간 다른 목적으로 사용됩니다:
- useTransition은 **상태 업데이트**의 우선순위를 낮춤
- useDeferredValue는 **값 자체**의 우선순위를 낮춤

## 6. Suspense, useDeferredValue, useTransition 비교

세 기능 모두 React의 동시성 모드를 활용하지만, 목적과 사용 사례가 다릅니다:

### Suspense
- **목적**: 비동기 작업 완료를 `기다리는 동안 대체 UI 표시`
- **사용 상황**: 데이터 로딩, 코드 분할(lazy loading)
- **작동 방식**: 비동기 작업이 완료될 때까지 fallback UI 표시
- **Suspense 사용 시나리오**
  - 상황: 사용자 프로필 정보를 API에서 가져와야 하는 경우
  - 문제점:
    - 데이터가 로드되는 동안 사용자에게 무엇인가를 보여줘야 함
    - 로딩 상태를 컴포넌트마다 개별적으로 관리하면 코드가 복잡해짐
  - Suspense 사용 이유:
    - 데이터가 준비될 때까지 fallback UI를 선언적으로 표시
    - 로딩 로직을 데이터 패칭 계층에서 처리하고 UI 컴포넌트는 데이터가 있다고 가정하고 작성 가능
    - 여러 비동기 작업을 하나의 로딩 상태로 조정 가능
- **실제 활용 사례:**
  - React Router의 라우트 기반 코드 스플리팅
  - React Query, SWR 등의 데이터 페칭 라이브러리와 함께 사용
  - 큰 이미지나 미디어 리소스 로딩 처리

### useTransition - 상태 업데이트의 우선순위 조정
- **목적**: `상태 업데이트의 우선순위를 낮추고` 이전 UI 유지(UI 반응성을 유지)
- **사용 상황**: 무거운 상태 전환 작업, 라우트 변경
- **작동 방식**: 상태 업데이트를 지연시키면서 UI 반응성 유지
- **형태**: `const [isPending, startTransition] = useTransition()`
- **useTransition 사용 시나리오**
  - 상황: 탭을 클릭하면 콘텐츠가 바뀌는 인터페이스, 각 탭은 렌더링이 무거운 콘텐츠를 포함
  - 문제점:
    - 탭 전환 시 즉시 무거운 렌더링이 실행되면 UI가 버벅거림
    - 탭 버튼 클릭 자체가 지연되어 사용자 경험이 저하됨
  - useTransition 사용 이유:
    - 탭 클릭은 즉시 반응하게 하되, 무거운 콘텐츠 전환은 지연시킴
    - isPending 상태를 이용해 전환 중임을 사용자에게 표시 가능
    - 이전 탭 콘텐츠를 유지하면서 새 탭 콘텐츠로 자연스럽게 전환
- **실제 활용 사례:**
  - 복잡한 대시보드 전환
  - 라우팅/페이지 전환
  - 무거운 필터링 조건 변경
  - 테마 전환과 같은 광범위한 UI 변경

### useDeferredValue - 값 자체의 우선순위를 낮춤
- **목적**: `값의 업데이트 우선순위를 낮춤`
- **사용 상황**: 프롭이나 상태에 기반한 무거운 렌더링 작업
- **작동 방식**: 값의 지연된 버전을 반환하고 UI 반응성 유지
- **형태**: `const deferredValue = useDeferredValue(value)`
- **useDeferredValue 사용 시나리오**
  - 상황: 사용자 입력에 따라 대용량 제품 목록을 필터링하는 검색 인터페이스
  - 문제점:
    - 사용자가 입력할 때마다 무거운 필터링 작업이 실행되면 입력이 버벅거림
    - 필터링 작업이 완료될 때까지 입력이 지연되어 타이핑 경험이 저하됨
    - 외부에서 받은 searchText prop의 변경을 직접 제어할 수 없음
  - useDeferredValue 사용 이유:
    - 입력값을 즉시 업데이트하면서 필터링 작업은 지연시킴
    - 사용자 입력은 항상 즉시 반응하도록 유지
    - isStale 상태로 UI가 업데이트 중임을 표시
- **실제 활용 사례:**
  - 타사 컴포넌트나 라이브러리와 함께 사용할 때 (상태 업데이트를 직접 제어할 수 없는 경우)
  - 복잡한 차트나 데이터 시각화
  - 대용량 테이블 필터링
  - 프롭 기반 무거운 계산이 필요한 컴포넌트

### 세 기능의 주요 차이점 (상세 비교)

#### 1. 제어 대상의 차이

- **Suspense**: 비동기 작업(Promise)을 제어
- **useTransition**: 직접 제어하는 상태 업데이트(setState)를 제어
- **useDeferredValue**: 외부에서 받은 prop이나 직접 제어할 수 없는 값(Props, state 등)을 제어

#### 2. 사용 패턴의 차이

- **Suspense**: 선언적 래퍼 컴포넌트 - `<Suspense fallback={...}>`
- **useTransition**: 명령적 함수 호출 - `startTransition(() => {...})`
- **useDeferredValue**: 값 변환 - `const deferred = useDeferredValue(value)`

#### 3. 사용 용도 (구체적 상황)

- **Suspense**:
  - API에서 데이터를 로드하는 동안 로딩 UI 표시
  - React.lazy로 코드 스플리팅된 컴포넌트를 불러올 때
  - 이미지/미디어 리소스가 준비될 때까지 대기

- **useTransition**:
  - 무거운 필터 변경이나 페이지 전환과 같은 큰 UI 상태 변경
  - 사용자가 탭이나 버튼을 클릭해서 다른 뷰로 전환할 때
  - 상태 업데이트의 결과로 렌더링이 많이 필요한 경우
  - 상태 업데이트를 직접 제어할 수 있는 컴포넌트에서 사용

- **useDeferredValue**:
  - 부모로부터 받은 props에 의존하는 무거운 렌더링
  - 제3자 라이브러리나 제어할 수 없는 소스에서 값을 받을 때
  - 부모 컴포넌트는 가볍게 유지하고 자식 컴포넌트의 무거운 연산만 지연시킬 때
  - 입력값을 필터링, 정렬 등에 사용하지만 입력 자체는 즉시 반응해야 할 때

#### 언제 어떤 것을 선택해야 할까요?

1. **비동기 데이터/리소스 로딩을 처리해야 할 때**:
   - Suspense 사용

2. **다음 상황에서는 useTransition 사용**:
   - 무거운 상태 업데이트가 있고
   - 해당 상태 업데이트 함수를 직접 호출하는 코드를 제어할 수 있고
   - 상태 업데이트 중임을 UI에 표시하고 싶을 때

3. **다음 상황에서는 useDeferredValue 사용**:
   - 무거운 렌더링 작업의 입력이 되는 값이 있고
   - 해당 값의 소스를 직접 제어할 수 없거나
   - 상태 업데이트 함수에 접근할 수 없거나
   - 기존 코드를 최소한으로 수정하고 싶을 때

동시성 특성을 활용하는 이 세 가지 도구는 각각 다른 상황에서 React 애플리케이션의 성능과 사용자 경험을 향상시키는 데 도움이 됩니다.

## 7. useDeferredValue와 디바운스, 스로틀링과의 차이점

useDeferredValue와 전통적인 성능 최적화 기법의 차이:

### 디바운스 (Debounce)
- **작동 방식**: 일정 시간 동안 추가 이벤트가 없을 때만 함수 실행
- **예시**: 사용자가 타이핑을 0.5초 동안 멈출 때까지 API 호출 지연
- **차이점**: useDeferredValue는 고정된 지연 없이 React의 리렌더링 우선순위에 따라 동적으로 조정

### 스로틀링 (Throttling)
- **작동 방식**: 일정 간격으로만 함수 실행을 허용
- **예시**: 스크롤 이벤트를 100ms마다 한 번씩만 처리
- **차이점**: useDeferredValue는 시간 간격이 아닌 브라우저/시스템 리소스 가용성에 따라 동작

### 주요 차이점:
1. **구현 레벨**: 디바운스/스로틀링은 JavaScript 레벨에서 타이머로 구현, useDeferredValue는 React 내부 스케줄러 활용
2. **동적 조정**: useDeferredValue는 시스템 부하에 따라 지연 시간을 동적으로 조정
3. **이전 UI 유지**: useDeferredValue는 새 값이 준비될 때까지 이전 UI를 보여줌
4. **우선순위 기반**: React의 concurrent 렌더링을 활용하여 우선순위 기반으로 작동

useDeferredValue는 디바운스/스로틀링보다 더 깔끔하고 선언적인 API를 제공하며, React의 렌더링 시스템과 더 깊게 통합됩니다.

useDeferredValue의 강점은 **렌더링 자체를 중단하고 재시작할 수 있는 React의 동시성 특성**을 활용해 **더 부드러운 사용자 경험**을 제공한다는 점입니다.

## 8. useDeferredValue 없이 대안 구현 방법

useDeferredValue가 React 18에서 도입되기 전에는 비슷한 효과를 얻기 위해 여러 대안적인 방법들이 사용되었습니다. 이 방법들은 각각 장단점이 있었습니다.

### (1) 디바운싱 (Debouncing)
가장 흔히 사용된 방법 중 하나로, 일정 시간 동안 추가 이벤트가 없을 때만 함수를 실행하는 방식입니다.
### (2) 스로틀링 (Throttling)
일정 시간 간격으로만 함수 실행을 허용하는 방식입니다.
### (3) 웹 워커 (Web Workers)
무거운 계산을 메인 스레드에서 분리하여 별도의 백그라운드 스레드에서 실행하는 방식입니다.
### (4) 렌더링 분할 (Chunked Rendering)
무거운 렌더링 작업을 작은 단위로 나눠서 여러 프레임에 걸쳐 실행하는 방식입니다.
### (5) requestAnimationFrame을 이용한 렌더링 최적화
브라우저의 애니메이션 프레임 타이밍에 맞춰 렌더링을 스케줄링하는 방법입니다.
### (6) React.memo와 useCallback을 이용한 최적화
컴포넌트 리렌더링을 최적화하여 성능을 개선하는 방식입니다.
### (7) 가상 리스트 (Virtualized Lists)
대량의 데이터를 처리할 때 화면에 보이는 항목만 렌더링하는 방식입니다.

