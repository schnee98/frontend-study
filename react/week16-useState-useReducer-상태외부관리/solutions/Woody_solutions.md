# 👨‍🏫 week 16 - A

## ▣ 5.2장: 리액트 훅으로 시작하는 상태 관리
## ▣ 5.2.1장: 가장 기본적인 방법: useState와 useReducer
## ▣ 5.2.2장: 지역 상태의 한계를 벗어나보자: useState 의 상태를 바깥으로 분리하기

### 1️⃣ Q. useState와 useReducer를 기반으로 하는 사용자 지정 훅의 한계는 무엇일까요?

`useState`와 `useReducer`를 사용하여 만든 사용자 지정 훅(custom hooks)은 편리하고 강력한 도구이지만, 몇 가지 한계점을 가지고 있습니다.  이러한 한계를 이해하는 것은 특히 대규모 애플리케이션을 설계할 때 중요할 수 있습니다. 여기 몇 가지 주요 한계점을 소개합니다:

1. **지역 상태의 한계:** `useState`와 `useReducer`로 생성된 상태는 그 상태를 사용하는 컴포넌트 내에서만 유효합니다.  
이것은 상태가 컴포넌트의 인스턴스별로 독립적이라는 것을 의미하며, 각 컴포넌트 인스턴스는 자신만의 상태 복사본을 가집니다.  
상태를 여러 컴포넌트 간에 공유하려면 추가적인 상태 관리 구조(예: Context API, Redux)가 필요합니다.

2. **상태의 파편화:** 각 컴포넌트가 독립적으로 상태를 관리함으로써, 상태 관리가 분산되고 조각화될 수 있습니다.  
이는 동일한 데이터에 대한 일관된 뷰를 유지하기 어렵게 만들 수 있습니다.   
특히, 여러 컴포넌트에서 같은 데이터를 다루어야 할 때 이 문제가 두드러질 수 있습니다.

3. **재사용성의 제한:** 사용자 지정 훅은 재사용성을 높이기 위해 설계되었지만, 훅이 특정 컴포넌트 로직에 너무 밀접하게 결합되어 있다면 다른 컴포넌트나 프로젝트에서 재사용하기 어려울 수 있습니다. 즉, 훅이 일반적인 경우보다 특정 사용 사례에 더 맞춰져 있을 수 있습니다.

4. **테스팅의 복잡성:** 사용자 지정 훅이 내부 상태를 많이 포함하고 있거나 복잡한 로직을 수행하는 경우, 테스트가 더 복잡해질 수 있습니다. 특히 상태 변화가 많은 경우, 훅의 모든 가능한 상태를 테스트하기 위해 추가적인 모의(mock) 작업이 필요할 수 있습니다.

5. **컴포넌트 간의 상태 동기화:** 여러 컴포넌트가 같은 상태를 공유할 경우, 상태를 업데이트하는 로직이 올바르게 관리되지 않으면 일부 컴포넌트에서 상태가 최신 상태로 업데이트되지 않을 수 있습니다.

이러한 한계들에도 불구하고, 많은 경우에서 `useState`와 `useReducer`는 간단하고 효율적인 상태 관리 솔루션을 제공합니다.  
그러나 상태 관리 요구 사항이 복잡하거나 애플리케이션의 크기가 클 경우, 보다 고급 상태 관리 솔루션이 필요할 수 있습니다.

<br/>

### 2️⃣ Q. 지역 상태의 한계를 극복하고 useState의 상태를 컴포넌트 밖에서 관리할 수 있는 방법엔 무엇이 있을까요?


### 1. Context API 사용
`Context API`는 리액트에서 상태를 전역적으로 관리할 수 있는 방법을 제공합니다. 상태를 컴포넌트 트리의 어느 단계에서든 접근하고 업데이트 할 수 있게 해줍니다. 컨텍스트를 통해 생성된 값은 `Provider` 컴포넌트에 의해 하위 컴포넌트에 전달되고, 이 컴포넌트들은 `useContext` 훅을 사용하여 상태를 소비할 수 있습니다. 이 방법은 중간 규모의 애플리케이션에 적합하며 상태의 깊은 중첩을 피할 수 있습니다.

### 2. 상태 관리 라이브러리 사용
`Redux`, `MobX`, `Zustand` 등의 상태 관리 라이브러리를 사용하는 것은 리액트 외부에서 상태를 관리할 수 있게 해줍니다. 이 라이브러리들은 애플리케이션의 다양한 부분에서 상태를 쉽게 공유하고 업데이트할 수 있는 메커니즘을 제공합니다. 이러한 라이브러리들은 보통 액션, 리듀서, 스토어 등의 개념을 사용하여 애플리케이션 상태를 중앙에서 관리하고, 상태 변경을 구독하는 방식으로 컴포넌트의 리렌더링을 유발합니다.

### 3. Custom Hooks와 External Storage
외부 저장소(예: localStorage, sessionStorage)를 사용하거나 전역 객체에 상태를 저장하고, 이 상태를 컴포넌트에서 직접 관리할 수 있는 사용자 지정 훅을 만들 수 있습니다. 이 방식은 상태를 외부에서 관리하지만, 리액트의 렌더링 사이클과 통합하기 위해서는 컴포넌트에서 상태가 변경될 때마다 강제로 리렌더링을 트리거하는 로직이 필요합니다.

### 리액트 클로저 외부에서 useState 관리
리액트의 `useState`를 클로저 외부에서 사용하려면 컴포넌트 리렌더링을 직접 제어해야 합니다.  
상태가 변경될 때 리액트가 자동으로 컴포넌트를 업데이트하지 않기 때문에, 상태 변경 시 *`forceUpdate`와 같은 메커니즘을 사용해 수동으로 컴포넌트를 업데이트해야 할 수 있습니다.  

이는 일반적으로 권장되는 패턴은 아니며, 상태의 동기화와 리렌더링 관리가 복잡해질 수 있습니다.
(*`forceUpdate` : React 컴포넌트의 메소드 중 하나로, React에게 현재 컴포넌트의 render 메소드를 호출하여 컴포넌트를 강제로 다시 그리도록 요청합니다. 이 메소드는 일반적으로 React의 데이터 흐름에 어긋나는 상황에서 사용되며, React의 선언적인 렌더링 패러다임에 부합하지 않기 때문에 가능한 사용을 피해야 합니다.)

각각의 방법은 사용 사례와 애플리케이션의 구조에 따라 장단점이 있으므로, 적절한 방법을 선택하는 것이 중요합니다. 일반적으로, 애플리케이션의 상태 관리 요구가 복잡하거나 여러 컴포넌트 간에 상태를 공유해야 하는 경우,
상태 관리 라이브러리를 사용하는 것이 가장 효과적일 수 있습니다.

<br/>

