# 👨‍🏫 week 21 - A

## ▣ [State를 사용해 Input 다루기](https://ko.react.dev/learn/reacting-to-input-with-state)

## ▣ [State 구조 선택하기](https://ko.react.dev/learn/choosing-the-state-structure#don-t-mirror-props-in-state)

## ▣ [컴포넌트 간 State 공유하기](https://ko.react.dev/learn/sharing-state-between-components)

### 1️⃣ Q. 선언형 프로그래밍과 명령형 프로그래밍의 차이점은 무엇인가요?

-   **선언형 프로그래밍**은 `무엇을 해야 하는지`를 설명하는 방식입니다.

예를 들어, React를 사용해 UI를 구축할 때, 특정 상태에 따라 어떤 UI를 보여주고 싶은 지 선언합니다.  
 개발자는 결과를 설명하고, 내부 동작은 프레임워크나 라이브러리가 처리(자동으로 업데이트)합니다.

이는 코드가 더 `간결`하고, 읽기 쉽고, 유지보수가 용이하게 합니다.

-   **명령형 프로그래밍**은 `어떻게 할지`를 설명합니다.

예를 들어, JavaScript의 전통적인 for 루프는 수행해야 할 구체적인 단계를 명시합니다.

이는 `세부적인 제어`를 가능하게 하지만, 코드가 길어지고 `복잡`해질 수 있습니다.

<br/>

### 2️⃣ Q. Props를 state에 미러링 하지 않아야 하는 이유는 무엇일까요?

```js
function Message({ messageColor }) {
  const [color, setColor] = useState(messageColor);
```

`데이터 동기화 문제`를 유발할 수 있습니다.  
즉, props가 변경될 때 state가 자동으로 업데이트되지 않으므로 `데이터 불일치`가 발생할 수 있습니다.

위 코드에서는 부모 컴포넌트가 나중에 다른 값의 messageColor를 전달한다면 (예를 들어, 'blue' 대신 'red'),  
color state 변수 가 업데이트되지 않습니다.
<b>State는 첫 번째 렌더링 중에만 초기화되기 때문입니다.</b>

<br/>

### 3️⃣ Q. 상태 끌어올리기(Lifting State Up)란 무엇이며, 장점과 단점은 무엇일까요?

`두 개 이상의 컴포넌트`가 `동일한 데이터`를 필요로 할 때, `공통 부모 컴포넌트로 상태를 끌어올려 관리`하는 방법입니다.  
이를 통해 하위 컴포넌트들은 상태를 직접 관리하지 않고, 부모 컴포넌트로부터 props로 전달받아 사용합니다.

**장점:**

-   **데이터 동기화:** 상태를 단일 위치에서 관리하므로 `데이터 일관성`을 유지할 수 있습니다.
-   **유지보수 용이:** 상태 관리 로직이 `중앙 집중화`되어, 버그를 찾고 수정하기 쉽습니다.

**단점:**

-   **복잡성 증가:** 상위 컴포넌트가 상태를 관리하게 되면, `구조가 복잡`해질 수 있습니다.
-   **재사용성 감소:** 일부 컴포넌트가 특정 부모 컴포넌트에 의존하게 되어, `재사용성이 떨어질 수` 있습니다.

<br/>
